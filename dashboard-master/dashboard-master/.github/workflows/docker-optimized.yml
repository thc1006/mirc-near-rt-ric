# Copyright 2017 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: üê≥ Optimized Docker Build

on:
  workflow_call:
    inputs:
      platforms:
        description: 'Target platforms for build'
        required: false
        default: 'linux/amd64,linux/arm64'
        type: string
      push:
        description: 'Push image to registry'
        required: false
        default: false
        type: boolean
      tags:
        description: 'Image tags'
        required: false
        default: ''
        type: string
      context:
        description: 'Build context'
        required: false
        default: '.'
        type: string
      dockerfile:
        description: 'Dockerfile path'
        required: false
        default: './aio/Dockerfile'
        type: string
    outputs:
      image-digest:
        description: 'Image digest'
        value: ${{ jobs.build.outputs.digest }}
      image-metadata:
        description: 'Image metadata'
        value: ${{ jobs.build.outputs.metadata }}
  workflow_dispatch:
    inputs:
      platforms:
        description: 'Target platforms for build'
        required: false
        default: 'linux/amd64,linux/arm64'
        type: choice
        options:
        - linux/amd64
        - linux/arm64
        - linux/amd64,linux/arm64
      push:
        description: 'Push image to registry'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  packages: write
  id-token: write
  attestations: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  GO_VERSION: '1.21'
  NODE_VERSION: '18.17.0'
  
  # Docker optimizations
  DOCKER_CLI_EXPERIMENTAL: enabled
  BUILDKIT_PROGRESS: plain
  DOCKER_BUILDKIT: 1

jobs:
  # Multi-stage optimized Docker build
  build:
    name: üèóÔ∏è Multi-Platform Docker Build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: ${{ fromJson('["linux/amd64", "linux/arm64"]') }}
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      metadata: ${{ steps.build.outputs.metadata }}
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Platform-specific optimizations
      - name: ‚öôÔ∏è Configure Build Environment
        run: |
          # Enable experimental features
          echo '{"experimental": true}' | sudo tee /etc/docker/daemon.json
          sudo systemctl restart docker
          
          # Optimize for the specific platform
          if [[ "${{ matrix.platform }}" == "linux/arm64" ]]; then
            echo "BUILDKIT_MULTI_PLATFORM=true" >> $GITHUB_ENV
          fi

      # Set up QEMU for cross-platform builds
      - name: üîß Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ matrix.platform }}

      # Advanced Docker Buildx setup
      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          version: latest
          platforms: ${{ matrix.platform }}
          driver-opts: |
            network=host
            image=moby/buildkit:buildx-stable-1
          config-inline: |
            [worker.oci]
              max-parallelism = 4
            [worker.containerd]
              namespace = "buildkit"

      # Login to registries
      - name: üîë Login to GitHub Container Registry
        if: inputs.push || github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract comprehensive metadata
      - name: üè∑Ô∏è Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=stable,enable=${{ startsWith(github.ref, 'refs/tags/v') }}
            type=sha,prefix={{branch}}-
          labels: |
            org.opencontainers.image.title=O-RAN Near-RT RIC Dashboard
            org.opencontainers.image.description=O-RAN Near Real-Time RAN Intelligent Controller Dashboard
            org.opencontainers.image.vendor=O-RAN Alliance
            org.opencontainers.image.documentation=https://github.com/${{ github.repository }}/blob/main/README.md
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.url=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
          annotations: |
            org.opencontainers.image.title=O-RAN Near-RT RIC Dashboard
            org.opencontainers.image.description=O-RAN Near Real-Time RAN Intelligent Controller Dashboard

      # Prepare build context and cache keys
      - name: üèéÔ∏è Prepare Build Context
        id: context
        run: |
          # Create cache keys based on multiple factors
          CACHE_KEY_BASE="${{ runner.os }}-${{ matrix.platform }}-${{ env.GO_VERSION }}-${{ env.NODE_VERSION }}"
          CACHE_KEY_DEPS="${CACHE_KEY_BASE}-${{ hashFiles('**/go.sum', '**/package-lock.json') }}"
          CACHE_KEY_SRC="${CACHE_KEY_DEPS}-${{ hashFiles('src/**', 'aio/**') }}"
          
          echo "cache-key-base=${CACHE_KEY_BASE}" >> $GITHUB_OUTPUT
          echo "cache-key-deps=${CACHE_KEY_DEPS}" >> $GITHUB_OUTPUT
          echo "cache-key-src=${CACHE_KEY_SRC}" >> $GITHUB_OUTPUT
          
          # Prepare build arguments
          BUILD_ARGS="GO_VERSION=${{ env.GO_VERSION }}
          NODE_VERSION=${{ env.NODE_VERSION }}
          BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          VCS_REF=${{ github.sha }}
          VERSION=${{ github.ref_name }}
          BUILDKIT_INLINE_CACHE=1"
          
          echo "build-args<<EOF" >> $GITHUB_OUTPUT
          echo "$BUILD_ARGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Multi-layer cache strategy
      - name: üèéÔ∏è Configure Build Cache
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ steps.context.outputs.cache-key-src }}
          restore-keys: |
            ${{ steps.context.outputs.cache-key-deps }}
            ${{ steps.context.outputs.cache-key-base }}

      # Optimized multi-stage build
      - name: üèóÔ∏è Build Docker Image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.context || '.' }}
          file: ${{ inputs.dockerfile || './aio/Dockerfile' }}
          platforms: ${{ matrix.platform }}
          push: ${{ inputs.push || (github.event_name != 'pull_request') }}
          tags: ${{ inputs.tags || steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          annotations: ${{ steps.meta.outputs.annotations }}
          build-args: ${{ steps.context.outputs.build-args }}
          cache-from: |
            type=gha,scope=${{ matrix.platform }}
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache-${{ matrix.platform }}
            type=local,src=/tmp/.buildx-cache
          cache-to: |
            type=gha,scope=${{ matrix.platform }},mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache-${{ matrix.platform }},mode=max
            type=local,dest=/tmp/.buildx-cache-new,mode=max
          provenance: true
          sbom: true
          outputs: |
            type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push=${{ inputs.push || (github.event_name != 'pull_request') }}
            type=docker,dest=/tmp/image-${{ matrix.platform }}.tar

      # Optimize cache storage
      - name: üîÑ Optimize Build Cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      # Upload image artifact for testing
      - name: üì§ Upload Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ matrix.platform }}
          path: /tmp/image-${{ matrix.platform }}.tar
          retention-days: 1

  # Image testing and validation
  test-image:
    name: üß™ Test Docker Image
    runs-on: ubuntu-latest
    needs: build
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
        test-type: [security, functionality, performance]
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üì• Download Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ matrix.platform }}
          path: /tmp

      - name: üì¶ Load Docker Image
        run: |
          docker load --input /tmp/image-${{ matrix.platform }}.tar
          docker image ls

      # Security testing
      - name: üîí Security Scan with Trivy
        if: matrix.test-type == 'security'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          format: 'json'
          output: 'trivy-results-${{ matrix.platform }}.json'
          severity: 'CRITICAL,HIGH'

      # Functionality testing
      - name: üß™ Functionality Tests
        if: matrix.test-type == 'functionality'
        run: |
          # Start container
          docker run -d --name test-container \
            -p 8080:8080 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          # Wait for container to start
          sleep 30
          
          # Basic health check
          curl -f http://localhost:8080/health || exit 1
          
          # API endpoint test
          curl -f http://localhost:8080/api/v1/overview || exit 1
          
          # Stop container
          docker stop test-container
          docker rm test-container

      # Performance testing
      - name: üìä Performance Tests
        if: matrix.test-type == 'performance'
        run: |
          # Start container with resource limits
          docker run -d --name perf-test \
            --memory=512m \
            --cpus=1.0 \
            -p 8080:8080 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          # Wait for startup
          sleep 30
          
          # Run performance test
          docker run --rm --network host \
            grafana/k6:latest run - <<EOF
          import http from 'k6/http';
          import { check } from 'k6';
          
          export let options = {
            vus: 10,
            duration: '30s',
          };
          
          export default function() {
            let response = http.get('http://localhost:8080/');
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response time < 1000ms': (r) => r.timings.duration < 1000,
            });
          }
          EOF
          
          # Cleanup
          docker stop perf-test
          docker rm perf-test

      - name: üì§ Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.platform }}-${{ matrix.test-type }}
          path: |
            trivy-results-*.json
            performance-results-*.json

  # Multi-platform manifest creation
  create-manifest:
    name: üì¶ Create Multi-Platform Manifest
    runs-on: ubuntu-latest
    needs: [build, test-image]
    if: inputs.push || github.event_name != 'pull_request'
    steps:
      - name: üîë Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üì¶ Create and Push Multi-Platform Manifest
        run: |
          # Create manifest list
          docker manifest create ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest-linux-amd64 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest-linux-arm64
          
          # Annotate platforms
          docker manifest annotate ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest-linux-amd64 \
            --os linux --arch amd64
          
          docker manifest annotate ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest-linux-arm64 \
            --os linux --arch arm64
          
          # Push manifest
          docker manifest push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

  # Container signing and attestation
  sign-image:
    name: ‚úçÔ∏è Sign Container Image
    runs-on: ubuntu-latest
    needs: create-manifest
    if: inputs.push || github.event_name != 'pull_request'
    steps:
      - name: üîß Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: üîë Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ‚úçÔ∏è Sign Container Image
        run: |
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build.outputs.digest }}

      - name: üìÑ Generate Attestation
        run: |
          cosign attest --yes --predicate-type=https://slsa.dev/provenance/v0.2 \
            --predicate=<(echo '{"buildType":"https://github.com/actions/workflow"}') \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build.outputs.digest }}

  # Cleanup and optimization
  cleanup:
    name: üßπ Cleanup & Optimization
    runs-on: ubuntu-latest
    needs: [build, test-image, create-manifest]
    if: always()
    steps:
      - name: üßπ Cleanup Build Artifacts
        uses: geekyeggo/delete-artifact@v4
        with:
          name: |
            docker-image-*
          failOnError: false

      - name: üìä Report Build Metrics
        run: |
          echo "Build completed successfully!"
          echo "Image digest: ${{ needs.build.outputs.digest }}"
          echo "Platforms: linux/amd64, linux/arm64"
          echo "Registry: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"